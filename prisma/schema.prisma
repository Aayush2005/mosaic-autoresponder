// Prisma Schema for Creator Outreach Follow-Up System
// Enhanced schema with type-safe enums, timestamptz, and optimized indexes

generator client {
  provider             = "prisma-client-py"
  interface            = "asyncio"
  recursive_type_depth = "5"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums for type safety
enum ThreadStatus {
  PROCESSING
  FOLLOWUP_ACTIVE
  DELEGATED
  COMPLETED
}

enum ReplyIntent {
  INTERESTED
  NOT_INTERESTED
  CLARIFICATION
  CONTACT_PROVIDED
  CONTINUE_OVER_EMAIL
  UNCLEAR
}

// Main email threads table
// Stores the primary state of each email conversation with creators
model EmailThread {
  id        Int      @id @default(autoincrement())
  messageId String   @unique @map("message_id") @db.VarChar(255)
  threadId  String   @map("thread_id") @db.VarChar(255)
  accountEmail String @map("account_email") @db.VarChar(255)
  creatorEmail String @map("creator_email") @db.VarChar(255)
  subject   String?  @db.Text

  // Initial reply tracking (nullable in case thread created before reply processed)
  initialReplyReceivedAt  DateTime?    @map("initial_reply_received_at") @db.Timestamptz(6)
  initialReplyProcessedAt DateTime?    @map("initial_reply_processed_at") @db.Timestamptz(6)
  initialReplyIntent      ReplyIntent? @map("initial_reply_intent")
  initialReplyHasContact  Boolean      @default(false) @map("initial_reply_has_contact")

  // Follow-up tracking
  currentStage       Int       @default(0) @map("current_stage")
  lastFollowupSentAt DateTime? @map("last_followup_sent_at") @db.Timestamptz(6)
  nextFollowupAt     DateTime? @map("next_followup_at") @db.Timestamptz(6)
  failedSends        Int       @default(0) @map("failed_sends")
  followupsSent      Int       @default(0) @map("followups_sent")

  // Status and completion tracking
  status            ThreadStatus @default(PROCESSING)
  stopReason        String?      @map("stop_reason") @db.VarChar(100)
  delegatedToHuman  Boolean      @default(false) @map("delegated_to_human")
  delegatedAt       DateTime?    @map("delegated_at") @db.Timestamptz(6)
  completedAt       DateTime?    @map("completed_at") @db.Timestamptz(6)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relations
  replies           EmailReply[]
  followupSends     FollowupSend[]
  stageTransitions  StageTransition[]

  // Indexes for performance
  @@index([status])
  @@index([accountEmail], map: "idx_email_threads_account")
  @@index([currentStage, lastFollowupSentAt], map: "idx_email_threads_stage_time")
  @@index([nextFollowupAt], map: "idx_email_threads_next_followup")
  @@index([threadId], map: "idx_email_threads_thread_id")
  @@index([creatorEmail], map: "idx_email_threads_creator")
  @@index([stopReason], map: "idx_email_threads_stop_reason")
  
  // Composite index for followup scheduling queries
  @@index([accountEmail, status, nextFollowupAt], map: "idx_account_status_nextfollowup")
  
  // Unique constraint: one thread per account (prevents duplicates)
  @@unique([threadId, accountEmail], map: "unique_thread_per_account")
  
  @@map("email_threads")
}

// Email replies table
// Tracks ALL replies received in a thread (initial + subsequent)
model EmailReply {
  id            Int      @id @default(autoincrement())
  emailThreadId Int      @map("email_thread_id")
  messageId     String   @unique @map("message_id") @db.VarChar(255)

  // Reply metadata
  receivedAt   DateTime @map("received_at") @db.Timestamptz(6)
  processedAt  DateTime @map("processed_at") @db.Timestamptz(6)
  replyToStage Int?     @map("reply_to_stage")

  // Email content
  subject  String? @db.Text
  bodyText String? @map("body_text") @db.Text
  bodyHtml String? @map("body_html") @db.Text

  // Analysis results
  intent            ReplyIntent? @map("intent")
  hasPhone          Boolean      @default(false) @map("has_phone")
  hasAddress        Boolean      @default(false) @map("has_address")
  extractedPhone    String?      @map("extracted_phone") @db.VarChar(50)
  extractedAddress  String?      @map("extracted_address") @db.Text

  // Additional extracted info
  analysisDetails Json? @map("analysis_details")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relations
  emailThread       EmailThread       @relation(fields: [emailThreadId], references: [id], onDelete: Cascade)
  stageTransitions  StageTransition[]

  @@index([emailThreadId], map: "idx_email_replies_thread")
  @@index([messageId], map: "idx_email_replies_message_id")
  @@index([replyToStage], map: "idx_email_replies_stage")
  @@index([receivedAt], map: "idx_email_replies_received")
  @@map("email_replies")
}

// Follow-up sends table
// Tracks each follow-up email we SENT
model FollowupSend {
  id            Int      @id @default(autoincrement())
  emailThreadId Int      @map("email_thread_id")
  stage         Int
  sentAt        DateTime @map("sent_at") @db.Timestamptz(6)
  templateUsed  String?  @map("template_used") @db.Text

  // Send status
  sendSuccess Boolean @default(true) @map("send_success")
  sendError   String? @map("send_error") @db.Text

  // Email details
  smtpMessageId String? @map("smtp_message_id") @db.VarChar(255)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relations
  emailThread EmailThread @relation(fields: [emailThreadId], references: [id], onDelete: Cascade)

  @@index([emailThreadId], map: "idx_followup_sends_thread")
  @@index([stage], map: "idx_followup_sends_stage")
  @@index([sentAt], map: "idx_followup_sends_sent_at")
  @@map("followup_sends")
}

// Stage transitions table
// Tracks when and why thread moved between stages
model StageTransition {
  id             Int          @id @default(autoincrement())
  emailThreadId  Int          @map("email_thread_id")
  fromStage      Int          @map("from_stage")
  toStage        Int          @map("to_stage")
  fromStatus     ThreadStatus @map("from_status")
  toStatus       ThreadStatus @map("to_status")

  // Transition reason
  reason              String? @map("reason") @db.VarChar(100)
  triggeredByReplyId  Int?    @map("triggered_by_reply_id")

  transitionedAt DateTime @default(now()) @map("transitioned_at") @db.Timestamptz(6)

  // Relations
  emailThread      EmailThread @relation(fields: [emailThreadId], references: [id], onDelete: Cascade)
  triggeredByReply EmailReply? @relation(fields: [triggeredByReplyId], references: [id], onDelete: SetNull)

  @@index([emailThreadId], map: "idx_stage_transitions_thread")
  @@index([transitionedAt], map: "idx_stage_transitions_time")
  @@map("stage_transitions")
}
